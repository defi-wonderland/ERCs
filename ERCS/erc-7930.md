---
eip: 7930
title: Interoperable Addresses
description: An extensible binary format to refer to an address specific to one chain.
author: Teddy (@0xteddybear), Joxes (@0xJoxess), Nick Johnson (@Arachnid), Francisco Giordano (@frangio), Skeletor Spaceman (@skeletor-spaceman), Sam Kaufman (@SampkaML), Marco Stronati (@paracetamolo), Yuliya Alexiev (@yuliyaalexiev), Jeff Lau (@jefflau), Sam Wilson (@samwilsn), Vitalik Buterin (@vbuterin)
discussions-to: https://ethereum-magicians.org/t/erc-7930-interoperable-addresses/23365
status: Draft
type: Standards Track
category: ERC
created: 2025-02-02
---

## Abstract
Interoperable Addresses is a binary format to describe an address specific to one chain with an optional human-readable name representation.

It is designed in a manner that allows the community extend it to support naming schemes (or other not-yet-imagined features) in the future, as well as to support arbitrary-length addresses and chainids.

## Motivation
The Ethereum ecosystem is rapidly expanding into a multi-chain environment encompassing L1s, L2s, sidechains, and rollups—some EVM‐compatible, others not. A simple address alone is not sufficient to describe a blockchain account, since it does not identify which chain the address belongs to, creating ambiguity for wallets, dApps, and users. At the same time, it is important for the format to be extensible to support both current standards for address naming and future standards for chain naming.

The current standard ethereum address representation defined in [EIP-55](./erc-55.md), with _optional_ retrofitted checksums implemented via selective capitalization of `a-f` characters, poses the following challenges:

- Verification of the checksum by a client is optional, meaning that mistyped or erroneous addresses may be accepted by these clients. There is no way for a user to distinguish a correct address from an incorrect one processed by a client that does not do validation.
- Addresses do not include any indication of the chain to which the address applies. This means chain information must be expressed out of band, and introduces the risk of an address being mistakenly used on a chain it is not valid for. This risk is particularly pronounced for addresses that represent smart contracts.
- The existing address format provides no mechanism for extension, meaning that there is no natural method to add these features to the existing address format.

Interoperable Addresses build on insights from [ERC-7828](./erc-7828.md), CAIP-10 and CAIP-50, offering a unified format which combines:
- Binding chain specificity (via explicit chain identifiers) to the raw address.
- Compact & canonical binary format for use on cross-chain message passing and intent declaration.
- Checksums for name collision mitigation & user error prevention.

Furthermore, we have taken this as an opportunity to add a few features that will make addresses interoperable with infrastructure at the edges of and beyond the ethereum ecosystem, by supporting the representation of addresses of non-evm chains as well, for the benefit of cross-chain liquidity movements and cross-chain message passing.

## Concepts
Interoperable Address
: A binary payload which unambiguously identifies a target address and allows conversion to a human-readable name.

Human-readable name
: A string representation of an interoperable address, meant to be used by humans.

Target address
: The (address, chain ID) pair a particular Interoperable Address points to.

## Guarantees provided by the standard
- Any future Interoperable Address will be trivially convertible to Interoperable Address v1 (specified below), which, together with the point below, makes them a canonical representation for users who need to treat them opaquely.
- Two Interoperable Addresses, converted to this canonical version, will be bitwise-equal if and only if they represent the same _target address_.
- Checksums are short enough to be compared by humans, and allow for easy differentiation of _target addresses_ independently of any extra data the Interoperable Address may contain.

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Interoperable Address binary format definition
In binary format addresses have the following encoding:

```
┌─────────┬───────────┬──────────────────────┬────────────────┬───────────────┬─────────┐
│ Version │ ChainType │ ChainReferenceLength │ ChainReference │ AddressLength │ Address │
└─────────┴───────────┴──────────────────────┴────────────────┴───────────────┴─────────┘
```

Where:

Version
: A 2-byte version identifier. In the current standard this must always be the big-endian unsigned int 1. Other versions should be defined in future ERCs.

ChainType
: A 2-byte value from the table in [Appendix A](#appendix-a-binary-encoding-of-caip-2-blockchain-id), corresponding to a CAIP-2 _namespace_, which allows users to know how to interpret & display the other two fields.

ChainReferenceLength
: A 1-byte integer encoding the length of ChainReference in bytes. Note that it MAY be zero, in which the Interoperable Address will not include a chain reference.

ChainReference
: Variable length, binary representation of CAIP-2 chain namespace & reference serialized as explained in [Appendix A](#appendix-a-binary-encoding-of-caip-2-blockchain-id) encoding the chain ID.

AddressLength
: 1-byte integer encoding the length of Address in bytes. Note that it MAY be zero, in which the Interoperable Address will not include an address. It MUST NOT be zero if `ChainReferenceLength` is also zero.

Address
: Variable length field containing the binary format of the address component. For EVM addresses this is always 20 bytes, for serialization details of other types of addresses see [Appendix B](#appendix-b-binary-encoding-of-addresses).

#### Restrictions for all Interoperable Address versions
- The Interoperable Address MUST define the mechanism to both include an address and specify the chain it belongs to directly in the payload, fully defining a target address. Any version adding an indirection layer between payload data and these two fields would violate this restriction.
    - While it is possible that a given instance of an Interoperable Address to not include an address or a chain reference, every version must allow for both to be specified at the same time.
    - Furthermore, future versions MUST be serialized to v1 and use the same input data to the checksum algorithm as described below, so an Interoperable Address' checksum only represents its target address.
- Interoperable Address versions MAY only be able to represent a subset of the CAIP namespaces.
- Interoperable Address versions MAY assign extra syntactic restrictions on the human-readable name, coupled to novel semantic meaning (e.g. use of ENS or other naming registries)
- Interoperable Address versions MAY define extra fields for purposes such as storing information on how to display the addresses.

### Human-readable name format definition
This section is considered OPTIONAL.

#### Syntax
```bnf
<human readable name> ::= <address>@<chain>#<checksum>
<address>             ::= [.-:_%a-zA-Z0-9]*
<chain>               ::= [.-:_a-zA-Z0-9]*
<checksum>            ::= [0-9A-F]{8}
```

Where:

Chain
: String representation of CAIP namespace, recovered from the binary representation described in [Appendix A](#appendix-a-binary-encoding-of-caip-2-blockchain-id). In the case where `ChainReferenceLength` is zero, it should be the empty string.

Address
: Chain namespace specific text representation of the address from the binary representation. Mapping between the two described in [Appendix B](#appendix-b-binary-encoding-of-addresses). In the case where `AddressLength` is zero, it should be the empty string.

Checksum
: 4-byte checksum calculated by computing the keccak256 hash of the concatenated `ChainType`, `ChainReferenceLength`, `ChainReference`, `AddressLength` and `Address` fields of the binary representation (that is, the v1 binary representation skipping the `Version` field), and truncating all but the first 4 bytes of the output. Represented as a base16 string as defined in RFC-4648.

## Rationale
- Chain and address fields' syntax is deliberately chosen to be able to express CAIP-2 namespaces (by using the `@` symbol for the separator, freeing up `:`) and CAIP-10 account IDs, with the caveat that no length restriction is placed, so chains with longer address formats or full 256-bit EVM chainids can be represented.
- Similarly, the address field includes `%` as a valid character to allow for url-encoding of any other characters.
- While a fresh start on text-encoding schemes could e.g. make use of more characters with base58 or base64 to achieve greater information efficiency and/or abstract which chain the address exists on as an implementation detail, we chose a more familiar approach since:
    - It makes the Interoperable Address <-> raw address relationship evident to the user, which will make the cases where the former are not (yet) supported by a dapp or hardware wallet easier to reason with, as users will evidently see the address is the same, but it's the chain&checksum that is being trimmed.
    - Its extra human-readability will make it more useful as a a stopgap solution until a standard focused on chain and address names is finalized.
- We chose to support zero-length addresses and chainids to be able to use just one standard to represent both potentially foreign _target addresses_ (e.g. the recipient of a cross-chain message) and also plain addresses or chainids (e.g. to specify the origin-chain hook address of a cross-chain message), for greater uniformity across implementations.

## Security Considerations

## Comparisons with other standards

### CAIP-10
CAIP-10 proposes a standard text format to represent what in this document is defined as target addresses. 
Since it's a text-only standard, it does not concern itself with the serialization/deserialization of the various chains' address formats, simply using the text representation of addresses already defined by the respective chains. This means it is trivial to add support for chains to CAIP-10, while doing so with this standard involves defining a serialization scheme.

The above has the drawback of not being able to guarantee canonicity. That is, there could be multiple valid CAIP-10 addresses pointing to the same target address.

Also, the text format is of little use for smart contracts involved with cross-chain liquidity transfers and message passing due to its reduced data efficiency and lack of canonicity.

Human-readable names are convertible to CAIP-10 without even going through the binary representation, so backwards-compatibility with actors expecting CAIP-10 identifiers should not be an issue.

### ERC-7828
[ERC-7828] is a text-only representation of addresses with optional resolution into more human-readable strings by use of existing ENS infrastructure for address names, and both the centralized ethereum-lists/chains list and ERC-7785 for resolution of chain names, while this aims to be a simple but extendable binary-first format.

We believe the interop roadmap is better served by having a standardized binary format for addresses first, which allows the message passing and intents verticals to move forward on a common interface, with a good-enough text representation which is familiar to users and useful for developers, and as a next step develop a chain & address name resolving standard on top of it, leveraging its uniformity and extensibility.

## Appendix A: Binary encoding of CAIP-2 blockchain ID
The `ChainType` field is the binary representation of the CAIP namespace (see table below), while the `ChainReference` contains the CAIP-2 reference, whose encoding is namespace-specific and defined below.

### CAIP namespaces' binary representation table

| Namespace | binary key |
| ---       | ---        |
| `eip155`    | `0x0000`   |
| `solana`    | `0x0002`   |

#### `eip155`

##### Text representation
```
eip155:<number>
```
Where `<number>` is the decimal representation of the chain's `chainid`, without leading zeroes.

##### Binary representation
The bare `chainid` encoded as a big-endian unsigned integer of the minimum necessary amount of bytes will be used [^1], and leading zeroes will be prohibited.

[^1]: This makes it possible to represent some chains using the full word as their chainid, which CAIP-2 does not support since the set of values representable with 32 `a-zA-Z0-9` characters has less than `type(uint256).max` elements. This is done in an effort to support chains whose ID is the output of `keccak256`, as proposed in ERC-7785.

##### Text -> binary conversion
Encode the decimal integer as a big-endian unsigned integer using the minimum necessary amount of bytes.

##### Binary -> text conversion
Compute the decimal representation of the stored big-endian unsigned integer

##### Examples
Ethereum Mainnet: `0x01` (1, encoded as uint8)

Optimism Mainnet: `0x0A` (10, encoded as uint8)

Ethereum Sepolia: `0xaa36a7` (11155111, encoded as uint24)

#### `solana`
Solana networks are distinguished by its genesis blockhash, which is normally represented as 44 base58btc characters, corresponding to 32 bytes. We chose to perform the same truncation as CAIP-2[^2] to keep representations trivially convertible between the two, making them also visually identical.

Truncating the base58btc-encoded representation instead of the binary data, however, means the binary representation will differ significantly from what the Solana node might store in its own memory.

[^2]: CAIP-2 limits chain references to 32 characters, so the `solana` namespace instructs to only use the first 32 characters of the base58btc-encoded genesis blockhash.

##### Text representation
The first 32 characters of the base58btc-encoded genesis blockhash are used. This is consistent with the CAIP-2 representation.

##### Binary representation
To obtain the binary representation from the base58btc-encoded genesis blockhash, first truncate the base58btc-encoded text to its first 32 characters as described above and then decode it to raw bytes.
It is worth noting that while this yields a 23-byte long result, it does not correspond to simply slicing the first 23 bytes from the genesis blockhash.

##### Text -> binary conversion
Text should be base58btc decoded into raw bytes

##### Binary -> text conversion
Raw bytes should be base58btc encoded into text

##### Examples
Solana Mainnet
: `solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp`
: `0x19e15de390a1bfea7ad6ed13c9898b4881b8aef9e705b31b`

Note that Solana Mainnet's blockhash is:
- base58btc `5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d`
- base16 `45296998a6f8e2a784db5d9f95e18fc23f70441a1039446801089879b08c7ef0`

## Appendix B: Binary encoding of addresses

### `eip155`
Bytes of EVM addresses are trivially stored as the payload. 
It's worth noting that addresses are currently 20 bytes, but that might change in the future, most likely to 32 bytes [^2]

[^2]: With EVM Object Format as a prerequisite, Address Space Expansion could be implemented. If that happens, expanded addresses may be represented in 32 bytes, but pre-expansion addresses must remain 20 bytes in order to preserve a consistent address.

##### Text representation
For text representation, the 20 bytes of EVM addresses should be hexadecimal-encoded according to EIP-55.
This standard deliberately does not define the text representation of EVM addresses if they are extended in the future, since it's not possible to know which human-readable representation will be more familiar to users in such hypothetical scenario. This responsibility is delegated to the relevant CASA profile.

##### Binary representation
Bytes of evm addresses are trivially stored as the payload.
It's worth noting that addresses are currently 20 bytes, but that might change in the future, most likely to 32 bytes [^2]

##### Text -> binary conversion
Described in [EIP-55]

##### Binary -> text conversion
Described in [EIP-55]

### `solana`
Solana addresses are 32-byte public keys, usually shown to users as base58btc-encoded text

##### Text representation
base58btc-encoded text

##### Binary representation
32-byte public key

##### Binary -> text conversion
base58btc encoding

#### Examples
`7S3P4HxJpyyigGzodYwHtCxZyUQe9JiBMHyRWXArAaKv` -> `0x5F90554BB3D8C2FC82B6EE59C49AAA143E77F7D49A83E956CE1DBEF17A43F805`

`DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK` -> `0xBA7A74F374AB05B70D114A78112EF0D3F0695A819572C79710B5372000D81AE2`

## Test cases

### Example 1: Ethereum mainnet address
Chain: Ethereum Mainnet
Address: `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`

Human-readable representation: `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045@eip155:1#4CA88C9C`

Binary representation:
```
0x00010000010114D8DA6BF26964AF9D7EED9E03E53415D37AA96045
  ^^^^-------------------------------------------------- Version:              decimal 1
      ^^^^---------------------------------------------- ChainType:            2 bytes of CAIP namespace
          ^^-------------------------------------------- ChainReferenceLength: decimal 1
            ^^------------------------------------------ ChainReference:       1 byte to store uint8(1)
              ^^---------------------------------------- AddressLength:        decimal 20
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Address:              20 bytes of ethereum address
```
keccak256 input for checksum: `0x0000010114D8DA6BF26964AF9D7EED9E03E53415D37AA96045`
note the version field is removed before hashing

### Example 2: Solana mainnet address
Chain: Solana Mainnet

Address: `MJKqp326RZCHnAAbew9MDdui3iCKWco7fsK9sVuZTX2`

Human-readable representation: `MJKqp326RZCHnAAbew9MDdui3iCKWco7fsK9sVuZTX2@solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp#4A58ACC6`

Binary representation:
```
0x0001000217e15de390a1bfea7ad6ed13c9898b4881b8aef9e705b31b2005333498d5aea4ae009585c43f7b8c30df8e70187d4a713d134f977fc8dfe0b5
  ^^^^---------------------------------------------------------------------------------------------------------------------- Version:              decimal 1
      ^^^^------------------------------------------------------------------------------------------------------------------ ChainType:            2 bytes of CAIP namespace
          ^^---------------------------------------------------------------------------------------------------------------- ChainReferenceLength: decimal 23
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^------------------------------------------------------------------ ChainReference:       23 bytes of truncated solana genesis block
                                                          ^^---------------------------------------------------------------- AddressLength:        decimal 32
                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^--- Address:              32 bytes of solana address
```
keccak256 input for checksum: `0x000217e15de390a1bfea7ad6ed13c9898b4881b8aef9e705b31b2005333498d5aea4ae009585c43f7b8c30df8e70187d4a713d134f977fc8dfe0b5`.
Note the version field is removed before hashing.

### Example 3: EVM address without chainid
Chain: Not specified.
Address: `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045`
Human-readable representation: `0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045@#144A4B21`

Binary representation:
```
0x000100000014D8DA6BF26964AF9D7EED9E03E53415D37AA96045
  ^^^^------------------------------------------------ Version:              decimal 1
      ^^^^-------------------------------------------- ChainType:            2 bytes of CAIP namespace
          ^^------------------------------------------ ChainReferenceLength: zero, indicating no chainid
            ^^---------------------------------------- AddressLength:        decimal 20
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Address:              20 bytes of ethereum address
```
keccak256 input for checksum: `0x000100000014D8DA6BF26964AF9D7EED9E03E53415D37AA96045`
Note the version field is removed before hashing.

### Example 4: Solana mainnet network, no address
Chain: Solana Mainnet.

Address: Not specified.

Human-readable representation: `@solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp#DE9AAA3F`

Binary representation:
```
0x0001000217e15de390a1bfea7ad6ed13c9898b4881b8aef9e705b31b00
  ^^^^------------------------------------------------------ Version:              decimal 1
      ^^^^-------------------------------------------------- ChainType:            2 bytes of CAIP namespace
          ^^------------------------------------------------ ChainReferenceLength: decimal 23
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-- ChainReference:       23 bytes of truncated solana genesis block
                                                          ^^ AddressLength:        zero, indicating no address
```
keccak256 input for checksum: `0x000217e15de390a1bfea7ad6ed13c9898b4881b8aef9e705b31b00`.
Note the version field is removed before hashing.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).

[EIP-55](./erc-55.md)
[ERC-7828](./erc-7828.md)
