---
eip: 7828
title: Interoperable Addresses
description: A binary format to describe an address specific to one chain with a good-enough human-readable name representation, and the ability to extend it to support naming schemes in the future
author: Sam Kaufman (@SampkaML), Marco Stronati (@paracetamolo), Yuliya Alexiev (@yuliyaalexiev), Jeff Lau (@jefflau), Sam Wilson (@samwilsn), Vitalik Buterin (@vbuterin), Teddy (@0xteddybear), Joxes (@0xJoxess), Nick Johnson (@Arachnid)
discussions-to: https://ethereum-magicians.org/t/erc-7828-chain-specific-addresses-using-ens/21930
status: Draft
type: Standards Track
category: ERC
created: 2024-11-27
requires: CAIP-2 RFC-4648
---

## Abstract
A binary format to describe an address specific to one chain with a good-enough human-readable name representation, and the ability to extend it to support naming schemes (or other not-yet-imagined features) in the future.

## Motivation

The Ethereum ecosystem is rapidly expanding into a multi-chain environment encompassing L1s, L2s, sidechains, and rollups—some EVM‐compatible, others not. A simple address alone is not sufficient to describe a blockchain account, since it does not identify which chain the address belongs to, creating ambiguity for wallets, dApps, and users. At the same time, it is important for the format to be extensible to support both current standards for adress naming and future standards for chain naming.

The current standard ethereum address representation defined in EIP-55, wiht _optional_ retrofitted checksums implemented via selective capitalization of `a-f` characters, poses the following challenges:

- Verification of the checksum by a client is optional, meaning that mistyped or erroneous addresses may be accepted by these clients. There is no way for a user to distinguish a correct address from an incorrect one processed by a client that does not do validation.
- Addresses do not include any indication of the chain to which the address applies. This means chain information must be expressed out of band, and introduces the risk of an address being mistakenly used on a chain it is not valid for. This risk is particularly pronounced for addresses that represent smart contracts.
- The existing address format provides no mechanism for extension, meaning that there is no natural method to add these features to the existing address format.

Interoperable Addresses build on insights from previous iterations of this standard and related discussions (see CAIP-10, CAIP-50), offering a unified format which combines:
- Binding chain specificity (via explicit chain identifiers) to the raw address,
- Compact & canonical binary format for use on cross-chain message passing and intents
- Checksums for name collision mitigation & user error prevention.

Furthermore, we have taken this as an opportunity to add a few features that will make addresses interoperable with infrastructure at the edges of and beyond the ethereum ecosystem, by supporting the representation of addresses of non-evm chains as well, for the benefit of cross-chain liquidity movements and cross-chain message passing.

## Concepts
Interoperable Address
: A binary payload which unambiguously identifies a target address and allows conversion to a human-readable name.

Human-readable name
: A string representation of an interoperable address, meant to be used by humans.

Target address
: The (address, chain ID) pair a particular Interoperable Address points to.

## Guarantees provided by the standard
- Any future Interoperable Address will be trivially convertible to Interoperable Addres v1 (specified below), which, together with the point below, makes them a canonical representation for users who need to treat them opaquely.
- Two Interoperable Addresses, converted to this canonical version, will be bitwise-equal iff they represent the same _target address_.
- Checksums are short enough to be compared by humans, and allow for easy differentiation of _target addresses_ independently of any extra data the Interoperable Address may contain.

## General specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Binary Representation
In binary format addresses have the following encoding:

```
┌─────────┬────────────┬─────────┬─────────┬─────────┬──────────┐
│ Version │ Chainidlen │ Chainid │ Addrlen │ Address │ Checksum │
└─────────┴────────────┴─────────┴─────────┴─────────┴──────────┘
```

Where:

Version
: a 2-byte version identifier. In the current standard this must always be 1.

Chainidlen
: a 1-byte integer encoding the length of Chainid in bytes.

Chainid
: Variable length, binary representation of CAIP-2 chain namespace & reference serialized as explained in [Appendix A](#appendix-a-binary-encoding-of-caip-2-blockchain-id) encoding the chain ID.

Addrlen
: 1-byte integer encoding the length of Address in bytes.

Address
: Variable length field containing the binary format of the address component. For EVM addresses this is always 20 bytes, for serialization details of other types of addresses see [Appendix B](#appendix-b-binary-encoding-of-addresses)

#### Restrictions for all Interoperable Address versions
- The Interoperable Address MUST include an address and specify the chain it belongs to, fully defining a target address. Any version adding an indirection layer between payload data and these two fields would violate this restriction.
    - Furthermore, future versions MUST be serialized to v1 and use the same checksum algorithm, so an Interoperable Address' checksum only represents its target address.
- Interoperable Address versions MAY only be able to represent a subset of the CAIP-2 namespaces.
- Interoperable Address versions MAY assign extra syntactic restrictions on the human-readable name, coupled to novel semantic meaning (e.g. use of ENS or other naming registries)
- Interoperable Address versions MAY define extra fields containing information on how to display the addresses.

### Human-readable name format definition

#### Syntax
```bnf
<human readable name> ::= <account>@<chain>#<checksum>
<account>             ::= [-:_%a-zA-Z0-9]*
<chain>               ::= [-:_a-zA-Z0-9]*
<checksum>            ::= [0-9A-F]{8}
```

Where:

Chain
: String representation of CAIP-2 blockchain identifier, recovered from the binary representation described in [Appendix A](#appendix-a-binary-encoding-of-caip-2-blockchain-id)

Address
: Chain namespace specific text representation of the address from the binary payload. Mapping between the two described in [Appendix B](#appendix-b-binary-encoding-of-addresses)

Checksum
: 4-byte checksum calculated by computing the keccak256 hash of the binary representation, and truncating all but the first 4 bytes of the output. Represented as a base16 string as defined in RFC-4648

#### Rationale
- Chain and account fields' syntax is deliberately chosen to be able to express CAIP-2 namespaces (by using the `@` symbol for the separator, freeing up `:`) and CAIP-10 account IDs, with the caveat that no length restriction is placed, so chains with longer address formats or full 256-bit EVM chainids can be represented.
- Similarly, the account field includes `%` as a valid character to allow for url-encoding of any other characters.
- While a fresh start on text-encoding schemes could e.g. make use of more characters with base58 or base64 to achieve greater information efficiency and/or abstract which chain the address exists on as an implementation detail, we chose a more familiar approach since:
    - It makes the Interoperable Address <-> raw address relationship evident to the user, which will make the cases where the former are not (yet) supported by a dapp or hardware wallet easer to reason with, as users will evidently see the address is the same, but it's the chain&checksum that is being trimmed.
    - Its extra human-readability will make it more useful as a a stopgap solution until we finalize a standard focused on chain and address names

## Encoding considerations
- On-chain actors, such as smart contracts, MUST always receive and return the machine addresses as a byte array.
- On-chain actors, such as smart contracts, MAY only accept `v1` addresses, with off-chain actors being responsible over converting them to said format.
- Off-chain actors, such as wallets, MAY use the blockchain-native byte array representation, or, where practical MAY alternatively use base64 [^2] as defined in RFC-4648 to encode the former.
- Users SHOULD NOT be shown the base64 or other non-semantic stringifications of the binary representations. Instead, they should be presented with the intended human-readable name.

[^2]: Base64 was chosen since it is a more widely implemented standard than base58. Additionally, since machine addresses are not to be directly displayed to the user, the collision-avoidance reasons in favor of base58 do not apply

## Appendix A: Binary encoding of CAIP-2 blockchain ID
The first two bytes are the binary representation of CAIP-2 namespace (see table below), while the remaining bytes correspond to the CAIP-2 reference, whose encoding is namespace-specific and defined below.

### CAIP-2 namespaces' binary representation table

| Namespace | binary key |
| ---       | ---        |
| eip155    | `0x0000`   |
| bip122    | `0x0001`   |

#### eip155
The bare `chainid` encoded as a big-endian unsigned integer of the minimum necessary amount of bytes will be used [^1], and leading zeroes will be prohibited. 

[^1]: This makes it possible to represent some chains using the full word as their chainid, which CAIP-2 does not support since the set of values representable with 32 `a-zA-Z0-9` characters has less than `type(uint256).max` elements. This is done in an effort to support chains whose ID is the output of `keccak256`, as proposed in ERC-7785.

##### Examples
Ethereum Mainnet: `0x000001` (1, encoded as uint8)

Optimism Mainnet: `0x00000A` (10, encoded as uint8)

Ethereum Sepolia: `0x0000aa36a7` (11155111, encoded as uint24)

#### bip122
The genesis/fork blockhash is to be stored raw, without encoding/decoding from/to base58btc, and without removing any leading zeroes:

Note: CAIP-2 limits chain references to 32 characters, so converting to it will require truncating the reference, so converting _from_ actual CAIP-2 to this standard is potentially ambiguous (but converting from actual bip122 to this standard will never be).

##### Examples
Bitcoin Mainnet
: `0x0001000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f`

Litecoin
: `0x000112a765e31ffd4059bada1e25190f6e98c99d9714d334efa41a195a7e7e04bfe2`

## Appendix B: Binary encoding of addresses

### eip155
20 bytes of evm addresses trivially stored as the payload. For text representation, the EIP-55 format MUST be used.

### solana
base-58 encoded public keys should be decoded and stored as a 32 byte payload

#### Examples
`7S3P4HxJpyyigGzodYwHtCxZyUQe9JiBMHyRWXArAaKv` -> `0x5F90554BB3D8C2FC82B6EE59C49AAA143E77F7D49A83E956CE1DBEF17A43F805`

`DYw8jCTfwHNRJhhmFcbXvVDTqWMEVFBX6ZKUmG5CNSKK` -> `0xBA7A74F374AB05B70D114A78112EF0D3F0695A819572C79710B5372000D81AE2`

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).
