---
eip: 7828
title: Chain-specific addresses using ENS
description: A unified chain-specific address format that allows specifying the account as well as the chain on which that account intends to transact.
author: Sam Kaufman (@SampkaML), Marco Stronati (@paracetamolo), Yuliya Alexiev (@yuliyaalexiev), Jeff Lau (@jefflau), Sam Wilson (@samwilsn), Vitalik Buterin (@vbuterin)
discussions-to: https://ethereum-magicians.org/t/erc-7828-chain-specific-addresses-using-ens/21930
status: Draft
type: Standards Track
category: ERC
created: 2024-11-27
requires: 55, 137, 155, 7785
---

## Abstract
This proposal builds off of [ERC-7785](./eip-7785.md) (on-chain configs) to provide a standard and human-readable format for chain-specific L2 addresses:
- A unified format for accounts that specifies, together with the address, the chain where the address lives.
- The use of human-readable chain names and how they can be resolved to chain identifiers using ENS on L1.
- The use of human-readable account names and how they can be resolved to addresses using ENS on L2.

## Motivation
The current Ethereum address landscape is leading to an ecosystem that will have hundreds and eventually thousands of L2s that use the same address format as Ethereum mainnet. This means an address by itself is not enough information to know which chain the address is related to. This can be problematic if funds are sent to an unreachable address on the incorrect chain. From the user account it should be possible to obtain the right chain identifier (chainID) to include in a transaction. 

The mapping from chain names to identifiers has, since [EIP-155](./eip-155.md), been maintained off chain using a centralized list. This solution has two main shortcomings:
 - It does not scale with the growing number of L2s.
 - The list maintainer is a trusted centralized entity.

Instead of using chain identifiers, which are not human readable, the address could be extended with a human-readable chain name, which can then be resolved to a chain identifier.
The mapping from chain names to identifiers can be resolved off-chain using existing centralized lists or on-chain using ENS (see ERC-7785).

In the same spirit, the address could be a human-readable name as well, which is already a use case for ENS. However it would be desirable if the address name could be registered on a L2.

Desired properties:
- a unified format to represent any address on L1 or L2
- the ability to use chain names in addition to identifiers
- the chain portion can be a domain name, or just the suffix for a "base chain" (eg. `eth`, `myfavoriterollup.eth`, `sepolia`, `my_l3.base.superchain.eth`)
- the address portion can be either the appropriate type of address for the chain (0x... for EVM chains, otherwise eg. for starknet something else), or a domain name (ENS or other)
- the ability to resolve ENS names on the L2
- the address portion and the chain portion should be resolved separately 
- checksums are MANDATORY
- checksum hash goes over the entire address, so users can't just replace a component and expect it to stay valid

## Specification
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Format
This standard defines a sub-syntax with extra semantics on top of the syntax defined in [ERC-X].

```
<human readable name>: := <address>@<chain>#<checksum>
<address>:             := <raw-address> | <scoped-name>
<chain>:               := <raw-address> | <scoped-name>
<checksum>:            := [0-9A-F]{8}

<raw-address>:         := [.-:_%a-zA-Z0-9]*
<raw-chain>:           := [.-:_a-zA-Z0-9]*
<scoped-name>:         := <subdomain> . <L0-TLD>
<L0-TLD>:              := [_a-zA-Z0-9]{1,10}
```

Where:

- `<scoped-name>` : Corresponds to a full, resolvable name on the registry defined by its `L0-TLD`
- `<raw-chain>`, `<raw-address>` and `<checksum>` are defined to maintain backwards compatibility with [ERC-X], and their semantics remain the same.
- `<L0-TLD>`: Corresponds to an entry in the centralized [name resolver registry]
<!-- TODO: specify this better -->
- `<subdomain>`: Is a valid punycode string without `.` separators.

Note the difference between `<scoped-name>`, which is a fully qualified name, and `subdomain` that is just a segment of a name between dots. E.g. `user.app.eth` is a scoped name, `user` and `app` are subdomains.

This allows for Interoperable Addresses' text representation to mix and match 'resolved' and 'unresolved' usages in both the chain and address parts.

A few examples below:
```
Mainnet
- 0x12345...6789@eip155:1#FFFFFFFF
- 0x12345...6789@eth.short#FFFFFFFF
- alice.eth@eth.short#FFFFFFFF

Testnet (Sepolia)
- 0x12345...6789@eip155:11155111#00000000
- alice.testeth@sep.short#00000000

Rollup
- 0x12345...6789@eip155:4270#AAAAAAAA
- 0x12345...6789@arb-nova.short#AAAAAAAA
- alice.eth@arb-nova.short#AAAAAAAA

Assuming ERC-7785 starts listing chains at l2.eth
- alice.eth@arb-nova.l2.eth#AAAAAAAA

My ENS name is registered on rollup1 (via ENSIP-10 & ENSIP-16), but I want to receive funds on rollup2
- alice.rollup1.eth@rollup2.short#BBBBBBBB

Non-evm chain
- bc1..23@bip122:000000000019d6689c085ae165831e93#CCCCCCCC
- alice.eth@bip122:000000000019d6689c085ae165831e93#CCCCCCCC

Assuming the shortcode list adds a few other CAIP namespaces
- alice.eth@btc.short#CCCCCCCC
```

### Checksum
Addreses must be serialized to the `ChainType, ChainReferenceLength, ChainReference, AddressLength, Address` format proposed in [ERC-X] as Interoperable Addresses v1, and the 4-byte checksum MUST be displayed as part of the address as described in the syntax above.

This has the property of the checksum changing if any part of the address or chainid is modified, making dangerous manual modification of addresses an error case for wallet users, and also mitigates collisions where the same name is registered to different addresses on different registries

### The Name Resolver Registry
<!-- TODO: define where this list will live exactly and link to it if applicable -->
We propose for this ERC to strive to reach Final status instead of becoming a Living document, and maintain a separate dictionary for the different name resolving protocols or methods, similar to ethereum-lists/chains.

The keys of this list will be `<L0-TLD>`s, and their associated values should be:
- 2-byte binary id, for storing intended registry in Interoperable Addresses v2 (defined below)
- Chain naming section
    - The set of CASA namespaces on which the registry can provide names for chains.
    - An unambiguously implementable specification of how to obtain a name for a chain id.
    - An unambiguously implementable specification of how to obtain a chain id, given a network name.
    - The sources of truth the algorithms above should use.
- Address naming section
    - The set of CASA namespaces on which the registry can provide names for addresses
    - An unambiguously implementable specification of how to obtain a name for an address.
    - An unambiguously implementable specification of how to obtain a machine address, given a name.
    - The sources of truth the algorithms above should use.

<!-- TODO: examples for the centralized list with, say, `.shortname` L0-TLD. -->
<!-- TODO: examples for 7785 with, say, `.eth` L0-TLD. -->
It is worth noting that:
- The same `<L0-TLD>` can map to different algorithms and/or data for chains and addresses. e.g. if ERC-7785 is published as an ENS product, using `.eth` on a chain name will use a different algorithm for resolution than if the same TLD were used on an address.
- A given protocol may have more than one TLD assigned to it, to avoid having to store the chainid & address of the name resolver on the Interoperable Address itself. An example of this would be to use different addresses for the testnet & mainnet ENS deployments.

This is an easier list to maintain than ethereum-lists/chains, since it does not have to list every single chain, and the problem of knowing which contracts are trustworthy as naming registries is one wallets would have to tackle anyway.

### Example entries for the `L0-TLD` list

#### `.short`
Binary id: `0x0000`

##### Chain naming

###### Supported CASA namespaces
Only those explicitly listed here

###### Resolution algorithm
Simply refer to the table below

| shortname  | CAIP-2 namespace | CAIP-2 reference (text)            |
| :--        | :--:             | :--:                               |
| `eth`      | `eip155`         | `1`                                |
| `oeth`     | `eip155`         | `10`                               |
| `arb-nova` | `eip155`         | `4270`                             |
| `btc`      | `bip122`         | `000000000019d6689c085ae165831e93` |
| `solana`   | `solana`         | `5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp` |

<!-- TODO: we could fill it programatically from ethereum-lists/chains or instead refer to it for eip155 -->  

##### Address naming
Not supported

#### `.eth`
Binary id: `0x0001`

###### Supported CASA namespaces
`eip155` and anything supported by SLIP-0044
Note that in the case of chains supported by SLIP-0044

##### Chain naming
Not currently supported, TBD in ERC-7785

##### Address naming
<!-- TODO: specify this better -->
Resolution and reverse-resolution of chain names is to be executed as defined in ENSIP-16, ENSIP-11 and ENSIP-10.

Some caveats for ENS support are:
- ENSIP-6 and ENSIP-17 are explicitly not supported, as they define names on different TLDs.
- While ENS could add support for other TLDs for forward resolution, this standard would require another entry on this list to support them. This does not apply to _reverse_, resolution, since those names are not ever displayed.
- For addresses on chains that are both supported by SLIP-0044 and the special scheme for the eip155 namespace defined in ENSIP-11, the latter should be used.
<!-- TODO: probably a few more edge cases -->

### Interoperable Address v2 definition
To allow for addresses to be serialized from human-readable names to an Interoperable Address, and then back to _the same_ human-readable name we define a new version of Interoperable Addresses which includes information on the desired naming registry.

Note that this is OPTIONAL, and wallets MAY disregard the extra information and use the registries they prefer instead, and/or serialize to Interoperable Addresses version 1.
```
┌─────────┬───────────┬──────────────────────┬────────────────┬───────────────┬─────────┬───────────────┬─────────────────┐
│ Version │ ChainType │ ChainReferenceLength │ ChainReference │ AddressLength │ Address │ ChainResolver │ AddressResolver │
└─────────┴───────────┴──────────────────────┴────────────────┴───────────────┴─────────┴───────────────┴─────────────────┘
```

Where:
<!-- TODO: should we go back to ERC-X to define that a given bit should mean it can also be parsed as v1? because it'd be the case for this one -->
- `Version` : A 2-byte version identifier. must be big-endian unsigned integer `2`.
- `ChainType`, `ChainReferenceLength`, `ChainReference`, `AddressLength`, `Address`: Same as in [ERC-X]
- `ChainResolver`: 2-byte identifier of the method used to resolve the chain to a human-readable string, from the name registry registry.
- `AddressResolver`: 2-byte identifier of the method used to resolve the address to a human-readable string, from the name registry registry.
<!-- TODO: should we skip them if ChainReferenceLength / AddressLength are zero? -->

### Resolution step-by-step example
1. Check the type of `chain`
   - if typeof(chain) == “ENS name”: go to step 2
   - if typeof(chain) == “L1 TLD”: go to step 3
   - if typeof(chain) == “chainId”: go to step 4
2. Resolve the ENS name's `text(chainENSName, ‘chain_id’)` record using [ERC-2544](./eip-2544.md) and skip to step 4
3. Use an offline mapping of `TLD => chainId` to find the relevant chainId.
4. Check if `account` is an ENS name, if not end the resolution process.
5. Generate the cointype using the chainId via ENSIP-11: `coinType = 0x80000000 | chainId`
6. Verify the bridge address by resolving `[chainId].id.eth`'s `name(name, 60)` record using [ERC-2544](./eip-2544.md)
7. Check if this name matches the ENS name representing the chain, continue otherwise consider the resolution a failure and error.
8. Resolve the ENS name's `addr(name, cointype)`

## Rationale
- We chose to use a centralized list of name registries, aka a name registry registry, since mapping of chain names to chain ids, aka on-chain configs (as proposed in [ERC-7785]) are not yet a solved problem. Therefore there is a need to maintain a list of possible implementations, including stopgap solutions such as relying on ethereum-lists/chains.

## Open Discussions
- Further constrain the syntax of human-readable names to minimize:
    - Collisions on names by e.g. UTS46 case foldig
    - Addresses that are valid ERC-7828 but cant be squeezed into ENS or comparable standards

## Backwards Compatibility
The naming scheme herein defined can represent all names supported by [ERC-X]

## Security Considerations

<!-- TODO: case where two naming registries list the same name as mapping to different addresses, how it is mitigated by the checksum, and how it affects binary-> string conversions and not string->binary -->

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).

<!-- TODO update this when Interoperable Addresses are assigned an ERC number and PR #1002 is merged -->   
[ERC-X]: ./ERC-X.md
[ERC-7785]: ./ERC-7785.md
[name resolver registry]: TODO
