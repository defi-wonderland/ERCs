---
eip: 7786
title: Cross-Chain Messaging Gateway
description: An interface for contracts to send and receive cross-chain messages containing arbitrary data.
author: Francisco Giordano (@frangio), Hadrien Croubois (@Amxx), Ernesto Garcia (@ernestognw), CJ Cobb (@cjcobb23), Sergey Gorbunov (@sergeynog)
discussions-to: https://ethereum-magicians.org/t/erc-7786-cross-chain-messaging-gateway/21374
status: Draft
type: Standards Track
category: ERC
created: 2024-10-14
---


## Abstract

This proposal describes an interface, and the corresponding workflow, for smart contracts to send arbitrary data through cross-chain messaging protocols. The end goal of this proposal is to have all such messaging protocols accessible via this interface (natively or using "adapters") to improve their composability and interoperability. That would allow a new class of cross-chain native smart contracts to emerge while reducing vendor lock-in. This proposal is modular by design, allowing users to leverage bridge-specific features through extra data and external sending logic through hooks while providing simple "universal" access to the simple feature of "just getting a simple message through".

## Motivation

Cross-chain messaging protocols (or bridges) allow communication between smart contracts deployed on different blockchains. There is a large diversity of such protocols with multiple degrees of decentralization, different architectures, implementing different interfaces, and providing different guarantees to users.

Because almost every protocol implements a different workflow using a specific interface, portability between bridges is currently basically impossible. This also prevents the development of generic contracts that rely on cross chain communication.

The objective of this ERC is to provide a standard interface, and a corresponding workflow, for performing cross-chain communication between contracts. Existing cross-chain communication protocols that do not natively implement this interface should be able to adopt it using adapter gateway contracts.

Compared to previous ERCs in this area, this ERC offers compatibility with chains outside of the Ethereum/EVM ecosystem, and it is extensible to support the different feature sets of various protocols while offering a shared core of standard functionality.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Message Field Encoding

A cross-chain message consists of a sender, recipient, payload, extra data, and optional hooks.

### Sender and Recipient

The sender account (in the source chain) and receiver account (in the destination chain) MUST be input in an Interoperable Address binary format, specified in ERC-7930, which MUST be serialized according to CAIP-350. The recipient field MAY be omitted or zeroed (contain an Interoperable Address with all fields set to zero) to indicate an unspecified destination, such as when a broadcast mode is employed and the final recipients are determined by the protocol itself.

### Payload

The payload is an opaque `bytes` value.

### Extra Data

`extraData` is an opaque `bytes` value. This field is OPTIONAL and MUST be interpreted only on origin. If left empty this field is considered not in use.

### Hook Data

The hook is a structure that invokes a low-level call in the source chain atomically after the message is sent. It is never forwarded to the destination chain as part of the core message sending flow. 

If unused, MUST be empty. It is RECOMMENDED to standardize hooks as part of new ERCs. For instance, Gateways MAY delegate hook execution to a dedicated *hook executor*. Nevertheless, implementation details are outside the scope of the standard. 

### Sending Procedure

A **Source Gateway** is a contract that uses a messaging protocol to send a message to a receiver on another chain. MUST implement `IERC7786GatewaySource`.

```solidity
interface IERC7786GatewaySource {
  // Optional Hook data struct
  struct HookData {
    address hook;        // Local origin chain address
    bytes hookPayload;   // Low-level call data: selector and parameters for the hook
    uint256 value;       // Optional, amount of native token forwarded to the hook 
  }
 
  // MessageSent event
  event MessageSent(
    bytes32 outboxId,  // Unique outbox ID (may be 0 if the gateway doesn’t track)
    bytes sender,      // Binary Interoperable Address
    bytes recipient,   // Binary Interoperable Address
    bytes payload,     // Message content
    bytes extraData,   // Optional encoded gateway metadata (leave empty if unused)
    HookData hookData  // Optional Hook data 
  );
  
  // sendMessage function
  function sendMessage(
      bytes calldata recipient,                   // Binary Interoperable Address 
      bytes calldata payload,                     // Message content
      bytes calldata extraData,                   // Optional encoded gateway metadata (leave empty if unused)
      HookData calldata hookData                  // Optional Hook data
  ) external payable returns (bytes32 outboxId);  // Unique ID (may be 0 if the gateway doesn’t track)
}
```

### `sendMessage`

Initiates the sending of a message.

Further action MAY be required by the gateway to make the sending of the message effective, such as providing payment for gas. See Post-processing.

SHOULD revert if it executes supplying `extraData` bytes that the underlying protocol does not support. 

MAY accept call value (native token) to be sent with the message. MUST revert if the call value is included, but it is not a feature supported by the gateway. It is unspecified how this value is represented on the destination.

MAY generate and return a unique non-zero *outbox identifier*, otherwise returning zero. This identifier can be used to track the message lifecycle in the outbox in events and for post-processing.

MUST emit a `MessageSent` event, including the optional outbox identifier returned by the function.

### `MessageSent`

This event signals that a would-be sender has requested a message to be sent.

If `outboxId` is present, post-processing MAY be required to send the message through the cross-chain channel.

### Post-processing through Hooks

After a sender has invoked `sendMessage`, further action MAY be required by the gateways to make the message effective. This is called *post-processing*. For example, some payment is typically required to cover the cost of executing the message at the destination.

The Gateway MUST call the hooks, and it MAY query the gateway for the query context for the hook execution logic. If the hook call returns false or reverts, `sendMessage` MUST revert.

The exact interface for any such action is out of this ERC’s scope. If post-processing hooks are expected, such actions MUST be restricted to the specified account.

### Reception Procedure

A **Destination Gateway** is a contract implementing a protocol to validate messages sent on other chains. The interface of the destination gateway and how it is invoked are out of scope of this ERC.

The protocol MUST ensure delivery of a sent message to the **recipient** using the `IERC7786Recipient` interface (specified below), which the recipient MUST implement.

Once the message can be safely delivered (see Properties), the gateway MUST invoke `receiveMessage` with the message identifier and contents, unless the sender or the receiver explicitly requested otherwise.

The `messageId` MUST be either empty or unique (for the calling gateway) to the message being relayed. The format of this identifier is not specified, and the gateway can use it at its own discretion. For example it can be an identifier of the `MessageSent` event that created the message.

The gateway MUST verify that `receiveMessage` returns the correct value, and MUST revert otherwise.

```solidity
interface IERC7786Recipient {
    function receiveMessage(
        bytes32 messageId,  // Unique ID supplied by the destination gateway
        bytes sender,       // Binary Interoperable Address representation
        bytes payload       // Message content
    ) external payable;
}
```

### `receiveMessage`

Delivery of a message sent from another chain.

The receiver MUST validate that the caller of this function is a **known gateway**, i.e., one whose underlying cross-chain messaging protocol it trusts.

### Interaction Diagram

```mermaid
sequenceDiagram
    participant User
    participant GatewayA as Source Gateway (Chain A)
    participant Hook as Hook (optional)
    participant GatewayB as Destination Gateway (Chain B)
    participant Receiver as Recipient

    User->>GatewayA: sendMessage
    GatewayA-->>Hook: execute hookData (optional)
    GatewayA->>GatewayA: emit MessageSent
    GatewayA-->>GatewayB: [Underlying protocol]
    GatewayB->>Receiver: receiveMessage
```

### Properties

The protocol underlying a pair of gateways is expected to guarantee a series of properties. For a detailed definition and discussion, we refer to XChain Research’s *Cross-chain Interoperability Report*.

- The protocol MUST guarantee Safety: A message is delivered at the destination if and only if it was sent at the source. The delivery process must ensure a message is only delivered once the sending transaction is finalized, and not delivered more than once. Note that there can be multiple messages with identical parameters that must be delivered separately.
- The protocol MUST guarantee Liveness: A sent message is eventually delivered to the destination, assuming Liveness and censorship-resistance of the source and destination chains.
- The protocol SHOULD guarantee Timeliness: A sent message is delivered at the destination within a bounded delivery time, which should be documented.
- The above properties SHOULD NOT rely on trust in some centralized actor. For example, safety should be guaranteed by some trustless mechanism such as a light client proof or attestations by an open, decentralized validator set. Relaying should be decentralized or permissionless to ensure liveness; a centralized relayer can fail and thus halt the protocol.

## Rationale

**Separation of concerns**

The interface keeps a single, predictable entry point and lets every bridge expose its peculiarities through two completely generic fields:

- `extraData` : an opaque blob the gateway consumes internally.
- `hookData`: an optional low-level call executed on the origin chain after the `sendMessage` logic.

This follows the separation‑of‑concerns principle: gateway‑specific parameters are surfaced through extraData, while application‑level logic is injected via hooks. Both mechanisms extend the core messaging primitive in a complementary, independent way.

An application can swap one gateway address for another in storage and emit the same messages. That portability guards the app against a gateway being paused, deprecated, or simply breaking. It also enables *bridge layering*: a “meta‑gateway” can relay the same opaque message through two or more underlying bridges, choosing the combination that gives the desired blend of liveness and safety.

**On Extra Data**

Some bridges need specific parameters provided by the sender. Those parameters are specified on the `extraData` parameter. If the sender leaves `extraData empty`, the gateway forwards the message without supplying any protocol‑specific metadata to the underlying bridge. Any additional information injected by other components is outside the gateway flow and therefore outside the scope.

Gateways MAY provide a view that returns a human‑readable decoding of extraData for off‑chain use. The exact name and signature of such a helper are left out of this ERC and can be standardised separately.

**On Hooks**

Hooks keep the core interface minimal while giving developers a plug‑and‑play extension point for post-processing, all without bloating the gateway or forcing the entire ecosystem to agree on new parameters. One example is payment for relayers to deliver the message in the destination. The flow might be:

1. `hook` points to the relayers payment contract address.
2. `hookData` encodes the call to pay the gas fee (`payForGas(messageId, gasAmount, refundAddress)`).
3. `value` includes the ETH (or native token) payment amount.

Suppose a “`RelayerPaymentsContract`” exposes the function:

```solidity
function payForGas(bytes32 messageId, uint256 gasAmount, address refundAddress)
  external payable;

```

The `hookData` passed to `sendMessage` would be:

```solidity
HookData({
  hook: address(RelayerPaymentsContract),
  hookPayload: abi.encodeCall(
    RelayerPaymentsContract.payForGas,
    (messageId, 300_000, userAddress)
  ),
  value: 0.02 ether
});
```

Since the low-level call could derive itself into other subsequent calls, hooks MAY call other hooks or have their conditional logic for sequential calls.

## Backwards Compatibility

Existing cross-chain messaging protocols implement proprietary interfaces. We recommend that protocols natively implement the standard interface defined here, and propose the development of standard adapters for those that don't.

## Security Considerations

**Handling addresses**

Interoperable Addresses (ERC‑7930) rely on CAIP‑350 serialization. Using non‑canonical encodings can lead to silent delivery failures. Gateways SHOULD reject non‑canonical encodings and MAY normalize them before emission.

**`ExtraData` parsing**

Because `extraData` is opaque to the interface, each gateway MUST validate its format and gracefully revert with an explicit error (e.g., `UnsupportedExtraData()`) if the blob cannot be decoded.  Never assume well‑formed input.

**Hook Execution**

Gateway never should call an untrusted hook directly. As it is recommended that hook calls have a dedicated executor, it is up to the protocol to ensure the hook entity is the expected one. After the call, the Gateway storage and allowances should be left untouched.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
